// Copied from Inflector
function convertParsingObjectToFormsArray(parsingObject) {
	if (!parsingObject) {
		console.warn(
			`parsingObject is ${parsingObject} in convertParsingObjectToFormsArray`,
		);
		return [];
	}
	if (Array.isArray(parsingObject)) {
		return parsingObject;
	}
	if (typeof parsingObject === 'string') {
		console.warn(`parsingObject is a string: ${parsingObject}`);
	}
	return (
		Object.entries(parsingObject)
			// .filter(object => object !== null && object !== undefined)
			.flatMap(([key, object]) => {
				// Exclude forms that the Inflector marked as incorrect.
				if (key === 'incorrect') {
					return [];
				}
				return convertParsingObjectToFormsArray(object);
			})
	);
}
function convertParsingObjectToFormsSet(parsingObject) {
	return new Set(convertParsingObjectToFormsArray(parsingObject));
}

function getFormsForOneLemmaAndEnclitic(lemmaObject, enclitic) {
	const formsSet = convertParsingObjectToFormsSet(lemmaObject.Forms[enclitic]);
	const formsWithLemma = [];
	formsSet.forEach((form) => {
		formsWithLemma.push({
			form: form,
			lemma: lemmaObject.Lemma,
			enclitic: enclitic,
		});
	});
	return formsWithLemma;
}

const enclitics = ['unencliticized', 'ne', 'que', 've'];

function getFormsForOneLemma(lemmaObject) {
	const formsSets = {};
	enclitics
		.filter((enclitic) => lemmaObject.Forms[enclitic])
		.forEach(
			(enclitic) =>
				(formsSets[enclitic] = getFormsForOneLemmaAndEnclitic(
					lemmaObject,
					enclitic,
				)),
		);
	return formsSets;
}

function getFormsForSeveralLemmata(lemmaObjects) {
	const formsObject = {};
	lemmaObjects.forEach((lemmaObject) => {
		const forms = getFormsForOneLemma(lemmaObject);
		enclitics
			.filter((enclitic) => forms[enclitic])
			.forEach((enclitic) => {
				forms[enclitic].forEach((formAndLemma) => {
					if (formsObject[formAndLemma.form]) {
						// console.log(`formsObject already has ${formAndLemma.}`)
						formsObject[formAndLemma.form].Lemmata.push(formAndLemma.lemma);
					} else {
						formsObject[formAndLemma.form] = {
							Lemmata: [formAndLemma.lemma],
							Enclitic: enclitic,
						};
					}
				});
			});
	});
	return formsObject;
}

function convertToText(outputAsObject) {
	let output = '';
	Object.entries(outputAsObject).forEach(([word, lemmataAndEnclitic]) => {
		// console.log({ word, lemmataAndEnclitic });
		const newLineOfOutput = `${word}	${lemmataAndEnclitic.Lemmata.join(' ')}	${
			lemmataAndEnclitic.Enclitic
		}\n`;
		output = output + newLineOfOutput;
	});
	return output;
}

////
//// Code that only runs in Node:
////

if (typeof require !== 'undefined') {
	const fs = require('fs');

	function runAllWords() {
		//// This file is generated by the Inflector by merging my source lemmata data with the inflected forms that the Inflector generates for each lemma.
		const inputFileUrl =
			'C:/Users/Duncan Ritchie/Documents/Code/velut/velutSideAssets/Json/lemmata-with-words-from-inflector_mongo.json';
		const outputFileUrl =
			'C:/Users/Duncan Ritchie/Documents/Code/velut/velutSideAssets/Json/output-from-lemmata-collator.txt';

		try {
			console.time('total');
			console.time('reading input');

			const inputFile = fs.readFileSync(inputFileUrl, 'utf-8');
			const inputLines = inputFile.split('\n').filter(Boolean);
			const inputLemmata = inputLines.map((line, index) => {
				if (!line) {
					console.error(`Line ${index} is ${line}`);
					return;
				}
				// console.log(line);
				return JSON.parse(line);
			});

			console.timeEnd('reading input');
			console.time('getting forms');

			const outputAsObject = getFormsForSeveralLemmata(inputLemmata);

			console.timeEnd('getting forms');
			console.time('writing text file');

			const output = convertToText(outputAsObject);
			fs.writeFileSync(outputFileUrl, output);

			console.timeEnd('writing text file');
			console.timeEnd('total');
		} catch (error) {
			console.error(error);
		}
	}

	runAllWords();
}
